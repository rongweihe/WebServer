

最近陆陆续续有学弟学妹来问我 Webserver 相关的事情，因为本职也有工作，平时比较忙，但思考了决定，我还是会抽出时间来继续维护。

# 常见的的问题汇总

#### 事件驱动模型的设计思想到底是啥？

事件驱动模型的设计思想是：一个无限循环的事件分发线程在后台运行，一旦做了某种操作就触发这个事件，这个事件就会被放置到事件队列中，事件分发任务的线程就会这个发生的事件找到对应的事件回调函数去处理。

#### 事件分发线程是根据啥去找到事件的回调函数并调用它呢？

答案是套接字：回调函数和套接字对应的，通过套接字找到对应的回调函数。

#### 事件驱动模型的优势是啥？

事件驱动的好处是占用资源少，效率高，可扩展性强，是支持高性能高并发的不二之选。因为是事件驱动，不需要分配固定的资源，仅仅使用几个线程就可以支持上万的连接，每个线程的利用率得到了最大提升。

#### IO 网络通信是怎么实现事件驱动模型的？

通过使用 poll、epoll 等 I/O 分发技术，可以设计出基于套接字的事件驱动程序，从而满足高性能、高并发的需求。

#### Reactor 模型是啥玩意？

Reactor 模型（中文叫做反应堆模型）也就是事件驱动模型或者是 Event loop 模型。
这个模型的核心有三点。

- 它存在一个无限循环的事件分发线程，或者叫做 reactor 线程、Event loop 线程。这个事件分发线程的背后，就是 poll、epoll 等 I/O 分发技术的使用。
- 第二，所有的 I/O 操作都可以抽象成事件，每个事件必须有回调函数来处理。acceptor 上有连接建立成功、已连接套接字上发送缓冲区空出可以写、通信管道 pipe 上有数据可以读，这些都是一个个事件，通过事件分发，这些事件都可以一一被检测，并调用对应的回调函数加以处理。
- Reactor 模型——解决了空闲连接占用资源的问题，Reactor 线程只负责处理 I/O 相关的工作，业务逻辑相关的工作都被裁剪成一个一个的小任务，放到线程池里由空闲的线程来执行。当结果完成后，再交给反应堆线程，由 Reactor 线程通过套接字将结果发送出去。所以，这个模式性能更优。
- 1：阻塞IO+多进程——实现简单，性能一般
  2：阻塞IO+多线程——相比于阻塞IO+多进程，减少了上下文切换所带来的开销，性能有所提高。
  3：阻塞IO+线程池——相比于阻塞IO+多线程，减少了线程频繁创建和销毁的开销，性能有了进一步的提高。
  4：Reactor+线程池——相比于阻塞IO+线程池，采用了更加先进的事件驱动设计思想，资源占用少、效率高、扩展性强，是支持高性能高并发场景的利器。

### single reactor thread + worker threads

<div  align="center">   <img src="https://cdn.jsdelivr.net/gh/rongweihe/ImageHost01/epoll/reactor01.png" width = "500" height = "400" align=center/> </div>

**需要注意的是：**和 I/O 事件处理相比，应用程序的业务逻辑处理是比较耗时的，比如 XML 文件的解析、数据库记录的查找、文件资料的读取和传输、计算型工作的处理等，这些工作相对而言比较独立，它们会拖慢整个反应堆模式的执行效率。

所以，将这些 decode、compute、enode 型工作放置到另外的线程池中，和反应堆线程解耦，是一个比较明智的选择。反应堆线程只负责处理 I/O 相关的工作，业务逻辑相关的工作都被裁剪成一个一个的小任务，放到线程池里由空闲的线程来执行。当结果完成后，再交给反应堆线程，由反应堆线程通过套接字将结果发送出去。

**服务端：**

![](https://cdn.jsdelivr.net/gh/rongweihe/ImageHost01/epoll/27-poll-server.png)